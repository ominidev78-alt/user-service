import Joi from 'joi';import crypto from 'crypto';import { Request, Response, NextFunction } from 'express';import { UserModel } from '../models/UserModel.js';import { HttpError } from '../core/HttpError.js';import { env } from '../config/env.js';import { walletService, authService } from '../app.js';import got from 'got';const userSchema = Joi.object({  name: Joi.string().min(2).required(),  email: Joi.string().email().allow('', null),  document: Joi.string().allow('', null),  externalId: Joi.string().allow('', null),});const idParamSchema = Joi.object({  id: Joi.number().integer().positive().required(),});function generateAppCredentials(): { appId: string; clientSecret: string } {  const appIdRandom = crypto.randomBytes(8).toString('hex');  const appId = `pg_live_${appIdRandom}`;  const secretRandom = crypto.randomBytes(16).toString('hex');  const clientSecret = `sk_live_${secretRandom}`;  return { appId, clientSecret };}export class UserController {  async create(req: Request, res: Response, next: NextFunction) {    try {      const { value, error } = userSchema.validate(req.body, {        abortEarly: false,      });      if (error) {        throw new HttpError(400, 'ValidationError', {          details: error.details.map((d) => d.message),        });      }      const { appId, clientSecret } = UserModel.generateRawCredentials();      const user = await UserModel.create({        ...value,        appId,        clientSecret,      });      let wallet = null;      try {        wallet = await walletService.get(`api/users/${user.id}/wallet`, {          headers: {            app_id: appId,            client_id: clientSecret,          },        }).json<any>();      } catch (wErr: any) {        console.error('[UserController] Failed to create wallet on wallet-service:', wErr.message);      }      return res.status(201).json({        ok: true,        user,        wallet,      });    } catch (err) {      next(err);    }  }  async createWithDeposit(req: Request, res: Response, next: NextFunction) {    try {      return res.status(201).json({        ok: true,        message: 'Usuário criado com depósito inicial (MOCK)',      });    } catch (err) {      next(err);    }  }  async list(req: Request, res: Response, next: NextFunction) {    try {      const users = await UserModel.findAll();      return res.json({ ok: true, data: users });    } catch (err) {      next(err);    }  }  async get(req: Request, res: Response, next: NextFunction) {    try {      const id = Number(req.params.id);      const user = await UserModel.findById(id);      if (!user) throw new HttpError(404, 'UserNotFound');      return res.json({ ok: true, data: user });    } catch (err) {      next(err);    }  }  async getCredentials(req: Request, res: Response, next: NextFunction) {    try {      const { value, error } = idParamSchema.validate(req.params);      if (error) {        throw new HttpError(400, 'ValidationError', {          details: error.details.map((d) => d.message),        });      }      const id = value.id;      const user = await UserModel.findById(id);      if (!user) throw new HttpError(404, 'UserNotFound', { userId: id });      let appId = user.app_id || (user as any).appId || (user as any).client_id || null;      let clientSecret = user.client_secret || (user as any).clientSecret || null;      if (!appId || !clientSecret) {        const generated = await UserModel.generateAndUpdateCredentials(id);        appId = generated.appId;        clientSecret = generated.clientSecret;      }      return res.json({        ok: true,        data: {          app_id: appId,          client_secret: clientSecret,        },      });    } catch (err) {      next(err);    }  }  async rotateCredentials(req: Request, res: Response, next: NextFunction) {    try {      const { value, error } = idParamSchema.validate(req.params);      if (error) {        throw new HttpError(400, 'ValidationError', {          details: error.details.map((d) => d.message),        });      }      const id = value.id;      const user = await UserModel.findById(id);      if (!user) {        throw new HttpError(404, 'UserNotFound', { userId: id });      }      const gwData = await authService.post(`api/internal/users/${id}/generate-credentials`, {        json: {}      }).json<any>();      const appId = gwData.appId || gwData.app_id || gwData.client_id || null;      const clientSecret =        gwData.clientSecret || gwData.appSecret || gwData.client_secret || gwData.secret || null;      if (!appId || !clientSecret) {        throw new HttpError(500, 'GatewayError', {          message: 'Resposta inválida ao gerar credenciais',        });      }      const updatedUser = await UserModel.findById(id);      return res.json({        ok: true,        data: {          app_id: updatedUser?.app_id,          client_secret: clientSecret,         },      });    } catch (err) {      next(err);    }  }}export const userController = new UserController();